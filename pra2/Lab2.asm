;**************************************************************************
; Lab1A.asm file
; AUTHOR: PABLO CUESTA SIERRA
; GROUP: 2292
;**************************************************************************
; MACROS
	STR_LEN		EQU 	100
	MAX_STR_LEN	EQU		90
    MATRIX_SIZE EQU     3
;**************************************************************************
; DATA SEGMENT DEFINITION
DATA SEGMENT
    DIVISOR     DB  MATRIX_SIZE
    BASE_10     DB  10
    CLR_SCREEN  DB 	1BH,"[2","J$"
	TITLE_   	DB 	1BH,"[4;27f MATRIX DETERMINANT",13,10,'$'
    SELECT_MSG  DB  "Select option:",13,10,'$'
    OPT1_MSG    DB  "1) CALCULATE THE DETERMINANT USING DEFAULT VALUES",13,10,'$'
    OPT2_MSG    DB  "2) CALCULATE THE DETERMINANT BY TYPING NEW VALUES",13,10,'$'
    OPT_REQUEST DB  "Select: $"
    MATRIX_REQUEST DB  "Enter 3x3 matrix by rows (left to right) in a single line,",13,10
                DB "with numbers separated by a space: a11 a12 a13 a21 a22 a23 a31 a32 a33",13, 10
                DB "Your matrix input: $"
	USER_ANSWER DB 	STR_LEN DUP (0)
    
    RES_INFO    DB "Operation:",13,10,'$'
    RES_MSSG1   DB "      $"
    RES_MSSG2   DB "|A| = $"
    RES_MSSG3   DB " = $"
    SEPARATOR   DB 9,"$"
     
    AUX_RES     DB 20 DUP(?)
    ASCII_RES   DB 20 DUP(?)
     
    A           DB  -1, -2, 3
                DB  -4, -5, 6
                DB  -7, 8, 32 ; INITIAL MATRIX
    ORG 200H
    B           DW  ? ; DETERMINANT RESULT 
DATA ENDS
;**************************************************************************
; STACK SEGMENT DEFINITION
STACKSEG SEGMENT STACK "STACK"
    DB 100H DUP (0)
STACKSEG ENDS
;**************************************************************************
; EXTRA SEGMENT DEFINITION
EXTRA SEGMENT

EXTRA ENDS
;**************************************************************************
; CODE SEGMENT DEFINITION
CODE SEGMENT
ASSUME CS: CODE, DS: DATA, ES: EXTRA, SS: STACKSEG
; BEGINNING OF MAIN PROCEDURE
BEGIN PROC
; INITIALIZE THE SEGMENT REGISTER WITH ITS VALUE
    MOV AX, DATA
    MOV DS, AX
    MOV AX, STACKSEG
    MOV SS, AX
    MOV AX, EXTRA
    MOV ES, AX
    MOV SP, 100H ; LOAD A STACK POINTER WITH THE HIGHEST VALUE
; END OF INITIALIZATIONS
; BEGINNING OF THE PROGRAMME
    MOV AH,9	                ; CLEAR SCREEN
	MOV DX, OFFSET CLR_SCREEN
	INT 21H
	
	MOV DX,OFFSET TITLE_
	INT 21H
	MOV DX,OFFSET SELECT_MSG
	INT 21H
	MOV DX,OFFSET OPT1_MSG
	INT 21H
	MOV DX,OFFSET OPT2_MSG
	INT 21H
    ; REQUEST USER TO ENTER 1 OR 2
    PUSH OFFSET OPT_REQUEST
	PUSH OFFSET USER_ANSWER
	CALL READ_STRING 		; READ INPUT
    CALL PRINT_CRLF
     
    CMP USER_ANSWER[2], '1'
    JE COMPUTE_OPERATIONS ; IF '1' IS ENTERED, COMPUTE THE DETERMINANT DIRECTLY
    ; IF '2' IS ENTERED, REQUEST MATRIX FROM USER
    PUSH OFFSET MATRIX_REQUEST
	PUSH OFFSET USER_ANSWER
	CALL READ_STRING 		; READ INPUT
    CALL PRINT_CRLF
    
    CALL PARSE_MATRIX       ; PARSE READ MATRIX INTO A

  COMPUTE_OPERATIONS:
    CALL CALCULATE_DETERMINANT ;CALCULATE THE DETERMINANT
    CALL PRINT_RESULT          ;PRINT THE RESULT

; END OF THE PROGRAMME
    MOV AX, 4C00H
    INT 21H
BEGIN ENDP

; TAKE MATRIX FROM USER INPUT (IN USER_ANSWER)
; AND PUT IT INTO THE PROGRAM 3X3 MATRIX: A
PARSE_MATRIX PROC 
    MOV BH, 0
    MOV BL, USER_ANSWER[1]     ; BX CONTAINS THE SIZE OF THE MATRIX
    MOV USER_ANSWER[BX+2], ' ' ; END STRING WITH A SPACE, FOR PARSING
    
    MOV SI, 0
    MOV BX, OFFSET USER_ANSWER[2] ; BEGINNING OF STRING
  PARSE_ONE_NUMBER:
    CALL FROM_ASCII
    MOV A[SI], AL
    INC SI
    CMP SI, MATRIX_SIZE*MATRIX_SIZE
    JNE PARSE_ONE_NUMBER
    
    RET 
PARSE_MATRIX ENDP 

; TAKES STRING THAT BEGINS IN BX, DISCARDS SPACES, 
; AND SAVES THE NUMBER IN AX, STOPING WHEN A SPACE IS FOUND
; AFTER EXECUTION, BX POINTS TO THE SPACE AFTER THE NUMBER
FROM_ASCII PROC
    DEC BX 
  FROM_ASCII_DISCARD_SPACES:
    INC BX
    CMP BYTE PTR [BX], ' '
    JE FROM_ASCII_DISCARD_SPACES 

    MOV AX, 0
    MOV CX, 0 ; STORE IN CX WHETHER THE NUMBER IS NEGATIVE     
    CMP BYTE PTR [BX], '-' 
    JNE FROM_ASCII_CALC_NUMBER 
    MOV CL, 1 ;NUMBER IS NEGATIVE 
    INC BX 
  FROM_ASCII_CALC_NUMBER:
    MOV DL, [BX]
    SUB DL, '0'            ;DL CONTAINS THE DIGIT
    MUL BASE_10
    ADD AL, DL 
    
    INC BX
    CMP BYTE PTR [BX], ' '
    JNE FROM_ASCII_CALC_NUMBER 

    JCXZ FROM_ASCII_END
    NEG AX              ;IF NUMBER IS NEGATIVE
  FROM_ASCII_END:
    RET 
FROM_ASCII ENDP

; PRINT THE RESULT OF THE MATRIX DETERMINANT
PRINT_RESULT PROC
    MOV AH, 9H
    MOV DX, OFFSET RES_INFO
    INT 21H 
    MOV DX, OFFSET RES_MSSG1
    INT 21H 
    MOV BX, OFFSET A
    CALL PRINT_ROW 
    CALL PRINT_CRLF
    
    MOV DX, OFFSET RES_MSSG2
    INT 21H 
    ADD BX, MATRIX_SIZE    
    CALL PRINT_ROW 

    MOV AH, 9H
    MOV DX, OFFSET RES_MSSG3
    INT 21H
    MOV AX, B 
    CALL PRINT_NUMBER
    CALL PRINT_CRLF
    
    MOV AH, 9H
    MOV DX, OFFSET RES_MSSG1
    INT 21H 
    ADD BX, MATRIX_SIZE
    CALL PRINT_ROW 
    CALL PRINT_CRLF
    
    RET 
PRINT_RESULT ENDP

; PRINTS A ROW POINTED TO BY BX OF SIZE MATRIX_SIZE
PRINT_ROW PROC
    PUSH AX 

    MOV AH, 2H 
    MOV DL, '|' 
    INT 21H 

    MOV SI, 0    
    MOV AL, BYTE PTR [BX][SI]
    CALL EXTEND_AX_SIGN
    CALL PRINT_NUMBER
    INC SI 
  PRINT_ROW_ITER:
    MOV AH, 9H 
    MOV DX, OFFSET SEPARATOR
    INT 21H

    MOV AL, BYTE PTR [BX][SI]
    CALL EXTEND_AX_SIGN
    CALL PRINT_NUMBER 

    INC SI 
    CMP SI, MATRIX_SIZE
    JNE PRINT_ROW_ITER 
    
    MOV AH, 2H 
    MOV DL, '|' 
    INT 21H 

    POP AX 
    RET 
PRINT_ROW ENDP 

; PRINTS CRLF
PRINT_CRLF PROC
    PUSH AX 
    MOV AH, 2H 
    MOV DL, 13 
    INT 21H  
    MOV DL, 10 
    INT 21H 
    POP AX 
    RET 
PRINT_CRLF ENDP 

; PRINTS THE NUMBER STORED IN AX (DELETES WHAT IS IN AX)
PRINT_NUMBER PROC 
    PUSH BX 
    PUSH DS 

    MOV BX, AX 
    CALL TO_ASCII_BX
    MOV DS, DX
    MOV DX, AX 
    MOV AH, 9H
    INT 21H

    POP DS
    POP BX 
    RET 
PRINT_NUMBER ENDP 

; TAKES AN INPUT IN BX (SIGNED NUMBER) AND CONVERTS 
; IT TO AN ASCII STRING ENDED IN '$' RETURNS WITH THE 
; STRING'S SEGMENT IN DX AND STRING'S OFFSET IN AX
TO_ASCII_BX PROC 
    PUSH SI
    PUSH DI

    MOV SI, 0
    MOV DI, 0
    MOV AX, BX
    CMP AX, 0      ; CHECK SIGN OF AX
    JGE CONVERT    ; JUMP IF AX POSITIVE
    NEG AX 
    MOV ASCII_RES[SI], '-'
    INC SI 
  CONVERT:
    DIV BASE_10 ; AH=AX%10, AL=AX/10
    ADD AH, '0'
    MOV AUX_RES[DI], AH
    INC DI 
    MOV AH, 0
    CMP AX, 0
    JNE CONVERT 
    
  INVERT_RES:
    DEC DI
    MOV AL, AUX_RES[DI]
    MOV ASCII_RES[SI], AL
    INC SI 
    CMP DI,0
    JNE INVERT_RES
     
    MOV ASCII_RES[SI],'$' ;END OF STRING 
     
    MOV AX, OFFSET ASCII_RES
    MOV DX, SEG ASCII_RES 
    
    POP DI
    POP SI
    RET 
TO_ASCII_BX ENDP 

; EXTEND THE SIGN OF AX (8 BITS TO 16 BITS)
EXTEND_AX_SIGN PROC
    MOV AH, 0
    CMP AL, 0
    JGE END_EXTEND_AX_SIGN 
    MOV AH, 0FFH
  END_EXTEND_AX_SIGN:
    RET 
EXTEND_AX_SIGN ENDP

; MULTIPLY AX*SI*BX WITH SIGNED 
; MULTIPLICATION AND STORE IT IN AX
MULT3 PROC 
    IMUL SI 
    IMUL BX 
    RET
MULT3 ENDP

; THIS FUNCTION PRINTS A STRING THAT HAS BEEN READ PREVIOUSLY.
; THIS STRING HAS THE FOLLOWING IN THE BASE:
;   BASE DB ?, [SIZE OF STRING], "STRING"
; SI POINTS TO THE BASE
PRINT_STR PROC NEAR 
	MOV BX, 0
  WRITE_CHAR:
	MOV DL,[SI+BX+2]		;WRITE A CHARACTER
	MOV AH,2
	INT 21H
	
	INC BX
	CMP BL, [SI+1]			;COMPARE WITH NUMBER OF CHARACTERS
	JNE WRITE_CHAR
	RET						;RETURN WHEN FINISHED
PRINT_STR ENDP

;THIS FUNCTION ASKS A QUESTION AND RETRIEVES THE ANSWER
;STACK CONTAINS: ..., QUESTION, ANSWER.
READ_STRING PROC NEAR
	PUSH BP
	MOV BP, SP

	MOV AH,9
	MOV DX, [BP+6]		;MUESTRA "ESCRIBE ...
	INT 21H       

	MOV AH,0AH			;ALMACENA EL NOMBRE TECLEADO
	MOV DX, [BP+4]
	MOV BX, DX			
	MOV BYTE PTR [BX+0], MAX_STR_LEN ; MAX NUMBER OF CHARS IN: STRING[0]
	INT 21H

	POP BP
	RET 4 ; TO DISCARD FUNCTION ARGUMENTS FROM THE STACK
READ_STRING ENDP

SI_MOD PROC 
    PUSH AX
    MOV AX, SI 
    DIV DIVISOR ; aH = ax % 3
    MOV AL, AH
    MOV AH, 0
    MOV SI, AX 
    POP AX
    RET
SI_MOD ENDP 

; CALCULATES THE DETERIMNANT IN 3X3 MATRIX A
; STORES THE RESULT IN B
CALCULATE_DETERMINANT PROC 
    MOV CX, 0
    MOV DI, 0 ; TOTAL RESULT
  ITER1:
    MOV AX, 0

    MOV BX, 0
    MOV SI, CX 
    MOV AL, A[BX][SI]
    CALL EXTEND_AX_SIGN
    PUSH AX 

    ADD BX, MATRIX_SIZE  
    INC SI 
    CALL SI_MOD   
    MOV AL, A[BX][SI]
    CALL EXTEND_AX_SIGN
    PUSH AX 
    
    ADD BX, MATRIX_SIZE 
    INC SI 
    CALL SI_MOD     
    MOV AL, A[BX][SI]
    CALL EXTEND_AX_SIGN
    
    POP BX ; NOW AX, BX, SI CONTAIN THE THREE VALUES TO BE MULTIPLIED
    POP SI
    CALL MULT3 ;MULTIPLY

    ADD DI, AX ; ADD MULTIPLICATION TO DI

    INC CX 
    CMP CX, MATRIX_SIZE
    JNE ITER1

  ; SECOND PART OF THE MATRIX MULTIPLICATION
    MOV CX, 0
  ITER2:
    MOV AX, 0

    MOV BX, 0
    MOV SI, 2
    SUB SI, CX 
    MOV AL, A[BX][SI]
    CALL EXTEND_AX_SIGN
    PUSH AX 

    ADD BX, MATRIX_SIZE  
    ADD SI, 2 
    CALL SI_MOD  
    MOV AL, A[BX][SI]
    CALL EXTEND_AX_SIGN
    PUSH AX 
    
    ADD BX, MATRIX_SIZE 
    ADD SI, 2 
    CALL SI_MOD     
    MOV AL, A[BX][SI]
    CALL EXTEND_AX_SIGN
    
    POP BX ; NOW AX, BX, SI CONTAIN THE THREE VALUES TO BE MULTIPLIED
    POP SI
    CALL MULT3 ;MULTIPLY

    SUB DI, AX ; SUBTRACT MULTIPLICATION FROM DI

    INC CX 
    CMP CX, MATRIX_SIZE
    JNE ITER2
     
    MOV B, DI 
     
    RET 
CALCULATE_DETERMINANT ENDP

; END OF THE CODE SEGMENT
CODE ENDS
; END OF THE PROGRAMME POINTING OUT WHERE THE EXECUTION BEGINS
END BEGIN
