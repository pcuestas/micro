;**************************************************************************
; Lab1A.asm file
; AUTHOR: PABLO CUESTA SIERRA
; GROUP: 2292
;**************************************************************************
; DATA SEGMENT DEFINITION

    MATRIX_SIZE EQU 3

DATA SEGMENT
    DIVISOR     DB  MATRIX_SIZE
    BASE_10     DB  10
    CLR_SCREEN  DB 	1BH,"[2","J$"
	TITLE_   	DB 	1BH,"[4;27f MATRIX DETERMINANT",13,10,'$'
    SELECT_MSG  DB  "Select option:",13,10,'$'
    OPT1_MSG    DB  "1) CALCULATE THE DETERMINANT USING DEFAULT VALUES",13,10,'$'
    OPT2_MSG    DB  "2) CALCULATE THE DETERMINANT BY TYPING NEW VALUES",13,10,'$'
    
    RES_MSSG1   DB "      $"
    RES_MSSG2   DB "|A| = $"
    SEPARATOR   DB " $"
     
    AUX_RES     DB 20 DUP(?)
    ASCII_RES   DB 20 DUP(?)
     
    A           DB  -1, -2, 3
                DB  -4, -5, 6
                DB  -7, 8, 32 ; INITIAL MATRIX
    ORG 200H
    B           DW  ? ; DETERMINANT RESULT 
DATA ENDS
;**************************************************************************
; STACK SEGMENT DEFINITION
STACKSEG SEGMENT STACK "STACK"
    DB 100H DUP (0)
STACKSEG ENDS
;**************************************************************************
; EXTRA SEGMENT DEFINITION
EXTRA SEGMENT

EXTRA ENDS
;**************************************************************************
; CODE SEGMENT DEFINITION
CODE SEGMENT
ASSUME CS: CODE, DS: DATA, ES: EXTRA, SS: STACKSEG
; BEGINNING OF MAIN PROCEDURE
BEGIN PROC
; INITIALIZE THE SEGMENT REGISTER WITH ITS VALUE
    MOV AX, DATA
    MOV DS, AX
    MOV AX, STACKSEG
    MOV SS, AX
    MOV AX, EXTRA
    MOV ES, AX
    MOV SP, 100H ; LOAD A STACK POINTER WITH THE HIGHEST VALUE
; END OF INITIALIZATIONS
; BEGINNING OF THE PROGRAMME
    MOV AH,9	                ; CLEAR SCREEN
	MOV DX, OFFSET CLR_SCREEN
	INT 21H
	
	MOV DX,OFFSET TITLE_
	INT 21H
	MOV DX,OFFSET SELECT_MSG
	INT 21H
	MOV DX,OFFSET OPT1_MSG
	INT 21H
	MOV DX,OFFSET OPT2_MSG
	INT 21H
    ;  --------------------------HERE GOES QUESTIONS TO USER ABOUT DATA
    
    CALL CALCULATE_DETERMINANT
    
    CALL PRINT_RESULT


; END OF THE PROGRAMME
    MOV AX, 4C00H
    INT 21H
BEGIN ENDP

PRINT_RESULT PROC
    MOV DX, OFFSET RES_MSSG1
    MOV AH, 9H
    INT 21H 
    MOV BX, OFFSET A
    CALL PRINT_ROW 
    CALL PRINT_CARRY
    
    MOV DX, OFFSET RES_MSSG2
    INT 21H 
    ADD BX, MATRIX_SIZE    
    CALL PRINT_ROW 

    MOV AH, 2H
    MOV DL, '='
    INT 21H
    MOV AX, B 
    CALL PRINT_NUMBER
    CALL PRINT_CARRY
    
    MOV AH, 9H
    MOV DX, OFFSET RES_MSSG1
    INT 21H 
    ADD BX, MATRIX_SIZE
    CALL PRINT_ROW 
    CALL PRINT_CARRY
    
    RET 
PRINT_RESULT ENDP

; PRINTS A ROW POINTED TO BY BX OF SIZE MATRIX_SIZE
PRINT_ROW PROC
    PUSH AX 

    MOV AH, 2H 
    MOV DL, '|' 
    INT 21H 

    MOV SI, 0    
    MOV AL, BYTE PTR [BX][SI]
    CALL EXTEND_AX_SIGN
    CALL PRINT_NUMBER
    INC SI 
PRINT_ROW_ITER:
    MOV AH, 9H 
    MOV DX, OFFSET SEPARATOR
    INT 21H

    MOV AL, BYTE PTR [BX][SI]
    CALL EXTEND_AX_SIGN
    CALL PRINT_NUMBER 

    INC SI 
    CMP SI, MATRIX_SIZE
    JNE PRINT_ROW_ITER 
    
    MOV AH, 2H 
    MOV DL, '|' 
    INT 21H 

    POP AX 
    RET 
PRINT_ROW ENDP 

PRINT_CARRY PROC
    PUSH AX 
    MOV AH, 2H 
    MOV DL, 13 
    INT 21H  
    MOV DL, 10 
    INT 21H 
    POP AX 
    RET 
PRINT_CARRY ENDP 

; PRINTS THE NUMBER STORED IN AX (DELETES WHAT IS IN AX)
PRINT_NUMBER PROC 
    CALL ASCII_AX 
    MOV DX, AX 
    MOV AH, 9H
    INT 21H
    RET 
PRINT_NUMBER ENDP 

ASCII_AX PROC 
    PUSH SI
    PUSH DI

    MOV SI, 0
    MOV DI, 0
    TEST AX, 8000H ; CHECK SIGN OF AX
    JZ CONVERT     ; JUMP IF AX POSITIVE
    NEG AX 
    MOV ASCII_RES[SI], '-'
    INC SI 
CONVERT:
    DIV BASE_10 ; AH=AX%10, AL=AX/10
    ADD AH, '0'
    MOV AUX_RES[DI], AH
    INC DI 
    MOV AH, 0
    CMP AX, 0
    JNE CONVERT 
    
INVERT_RES:
    DEC DI
    MOV AL, AUX_RES[DI]
    MOV ASCII_RES[SI], AL
    INC SI 
    CMP DI,0
    JNE INVERT_RES
     
    MOV ASCII_RES[SI],'$' ;END OF STRING 
     
    MOV AX, OFFSET ASCII_RES
    MOV DX, SEG ASCII_RES 
    
    POP DI
    POP SI
    RET 
ASCII_AX ENDP 

; EXTEND THE SIGN OF AX (8 BITS TO 16 BITS)
EXTEND_AX_SIGN PROC
    MOV AH, 0
    CMP AL, 0
    JG END_EXTEND_AX_SIGN 
    MOV AH, 0FFH
END_EXTEND_AX_SIGN:
    RET 
EXTEND_AX_SIGN ENDP

; MULTIPLY AX*SI*BX WITH SIGNED 
; MULTIPLICATION AND STORE IT IN AX
MULT3 PROC 
    IMUL SI 
    IMUL BX 
    RET
MULT3 ENDP

; THIS FUNCTION PRINTS A STRING THAT HAS BEEN READ PREVIOUSLY.
; THIS STRING HAS THE FOLLOWING IN THE BASE:
;   BASE DB ?, [SIZE OF STRING], "STRING"
; SI POINTS TO THE BASE
PRINT_STR PROC NEAR 
	MOV BX, 0
WRITE_CHAR:
	MOV DL,[SI+BX+2]		;WRITE A CHARACTER
	MOV AH,2
	INT 21H
	
	INC BX
	CMP BL, [SI+1]			;COMPARE WITH NUMBER OF CHARACTERS
	JNE WRITE_CHAR
	RET						;RETURN WHEN FINISHED
PRINT_STR ENDP

; CALCULATES THE DETERIMNANT IN 3X3 MATRIX A
; STORES THE RESULT IN B
CALCULATE_DETERMINANT PROC 
    MOV CX, 0
    MOV DI, 0 ; TOTAL RESULT
ITER1:
    MOV AX, 0

    MOV BX, 0
    MOV SI, CX 
    MOV AL, A[BX][SI]
    CALL EXTEND_AX_SIGN
    PUSH AX 

    ADD BX, MATRIX_SIZE  
    INC SI 
    MOV AX, SI 
    DIV DIVISOR ; aH = ax % 3
    MOV AL, AH
    MOV AH, 0
    MOV SI, AX    
    MOV AL, A[BX][SI]
    CALL EXTEND_AX_SIGN
    PUSH AX 
    
    ADD BX, MATRIX_SIZE 
    INC SI 
    MOV AX, SI 
    DIV DIVISOR ; aH = ax % 3
    MOV AL, AH
    MOV AH, 0
    MOV SI, AX    
    MOV AL, A[BX][SI]
    CALL EXTEND_AX_SIGN
    
    POP BX ; NOW AX, BX, SI CONTAIN THE THREE VALUES TO BE MULTIPLIED
    POP SI
    CALL MULT3 ;MULTIPLY

    ADD DI, AX ; ADD MULTIPLICATION TO DI

    INC CX 
    CMP CX, MATRIX_SIZE
    JNE ITER1

; SECOND PART OF THE MATRIX MULTIPLICATION
    MOV CX, 0
ITER2:
    MOV AX, 0

    MOV BX, 0
    MOV SI, 2
    SUB SI, CX 
    MOV AL, A[BX][SI]
    CALL EXTEND_AX_SIGN
    PUSH AX 

    ADD BX, MATRIX_SIZE  
    ADD SI, 2 
    MOV AX, SI 
    DIV DIVISOR ; aH = ax % 3
    MOV AL, AH
    MOV AH, 0
    MOV SI, AX    
    MOV AL, A[BX][SI]
    CALL EXTEND_AX_SIGN
    PUSH AX 
    
    ADD BX, MATRIX_SIZE 
    ADD SI, 2 
    MOV AX, SI 
    DIV DIVISOR ; aH = ax % 3
    MOV AL, AH
    MOV AH, 0
    MOV SI, AX    
    MOV AL, A[BX][SI]
    CALL EXTEND_AX_SIGN
    
    POP BX ; NOW AX, BX, SI CONTAIN THE THREE VALUES TO BE MULTIPLIED
    POP SI
    CALL MULT3 ;MULTIPLY

    SUB DI, AX ; SUBTRACT MULTIPLICATION FROM DI

    INC CX 
    CMP CX, MATRIX_SIZE
    JNE ITER2
     
    MOV B, DI 
     
    RET 
CALCULATE_DETERMINANT ENDP

; END OF THE CODE SEGMENT
CODE ENDS
; END OF THE PROGRAMME POINTING OUT WHERE THE EXECUTION BEGINS
END BEGIN
